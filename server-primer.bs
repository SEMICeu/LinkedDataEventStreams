<pre class='metadata'>
Title: LDES Server Primer
Shortname: LDES-SERVER
Level: 1
Status: LD
URL: https://w3id.org/ldes/server-primer
Markup Shorthands: markdown yes
Editor: Pieter Colpaert, https://pietercolpaert.be
Repository: https://github.com/SEMICeu/LinkedDataEventStreams
Abstract: This Server Primer for Linked Data Event Streams (LDES) provides practical guidance for data publishers on implementing and hosting an LDES server. LDES aims to help publishers balance between offering rich querying APIs and simple data dumps by proposing an event stream as the base API. This primer focuses on lightweight, scalable approaches and best practices for setting up and maintaining an LDES server.
</pre>

# Introduction # {#introduction}

This server primer is a living document of derived normative rules based on [the main consumer-oriented LDES specification](https://w3id.org/ldes/specification) and the [W3C TREE hypermedia specification](https://w3id.org/tree/specification).

A Linked Data Event Stream (LDES) is an append-only log consisting of *immutable* members. The term “member” could also be interpreted as “event”, “activity”, “observation”, “record”, or “immutable entity”. For example, “an observation states that at this timestamp a specific sensor observed 5°C”. However, since LDES extends the W3C TREE hypermedia specification, we use the term “member” for consistency.

<img height="500" src="overview.svg" alt="An overview of the LDES specification.">

# Serializations and HTTP Responses # {#serializations}

A server MUST provide data in either [[!n-quads]], [[!n-triples]], [[!trig]], [[!turtle]] or [[!json-ld]]. 
It MAY also provide multiple serializations using content negotiation.

Note: When using content negotiation, set `Vary: Accept`.

It SHOULD provide an `ETag` header on responses. If the page is immutable, it SHOULD provide a `Cache-Control: immutable` header.

If [[!json-ld]] is used, there is an example context at https://w3id.org/ldes/context. 
Do not reference this URL directly in production; copy it into your project. 
If you host an external context yourself, ensure robust caching with the `ETag` and/or `Cache-Control` max-age headers.

A provider SHOULD implement the [TREE Profile specification](https://w3id.org/tree/specification/profile) for performance. In this case, you MUST order members chronologically in the page (i.e., append the members to the file as you go).

Issue: We will try to generalize this in the future so that we can also integrate with [Jelly](https://jelly-rdf.github.io/dev). This binary serialization has the potential to raise performance drastically.

If the server is overloaded, it MUST provide a `429 Too Many Requests`. The client will then retry later.

# Context Information # {#context-information}

On the first page (root node), you MUST include context information about the LDES and this particular root node of the LDES.
For features and how a client would interpret them, see [the main spec](https://w3id.org/ldes/specification).

Using `tree:viewDescription` on the root node, you MAY also link to an entity (embedded in the same page) that contains the retention policy, or other context data about this view of the LDES (e.g., the `dcat:Distribution`, the `tree:SearchTree`, or the `ldes:EventSource`) as a named entity. This is useful, for example, if a producer would like to disambiguate the IRI for the `ldes:EventSource` from the root `tree:Node`.

Recommended context properties on the `ldes:EventStream`:
- `ldes:timestampPath` (chronological order)
- `ldes:sequencePath` (tie-breaking or alternative order)
- `ldes:pollingInterval` (expected seconds between new members)
- `tree:shape` (SHACL node shape for members)
- Versioning: `ldes:versionOfPath`, optional create/update/delete paths and objects
- Out-of-order versioning: `ldes:versionTimestampPath`, `ldes:versionSequencePath`
- Transactions (optional): `ldes:transactionPath`, `ldes:transactionFinalizedPath`, `ldes:transactionFinalizedObject`

# Paginating Your Event Stream # {#paginating}

Instead of a one- or two-dimensional pagination scheme, TREE/LDES lets you describe the relations you want and build the search tree you need. We recommend the following:
 * You SHOULD set the chronological order of your event stream using `ldes:timestampPath`. Other properties such as `ldes:sequencePath` MAY be used as an addition, or as an alternative. In the latter case, the ordering will be incremental based on the ordering of the XSD literal.
 * You SHOULD use the same `tree:path` in your relations as in your `ldes:timestampPath`. This way, a client knows you structured your search tree according to chronological order.
 * Use two relations towards one node, one with the lower bound and another with the upper bound of the time interval it directs to.
 * Start with 1 root node that contains links to member pages. If that gets too large, you can introduce another level.
 * All `xsd:dateTime` literals you publish SHOULD come with a timezone.

Every `tree:Node` MAY contain zero or more members and MAY contain zero or more relations.

## Entry Points and Discovery ## {#entry-points}

Publish a stable entry point for clients. Expose either:
- A page where the `ldes:EventStream` IRI `S` links with `tree:view <>` to the current page; or
- An `ldes:EventStream` IRI `S` that has exactly one `tree:view` triple pointing to the root node `R`.

Avoid ambiguity by ensuring there is exactly one `tree:view` for the entry point. If you rotate the root node over time, keep `R` stable or use redirects.

## Members ## {#members}

Members MUST be linked from the event stream identifier using `tree:member`. For example:

```turtle
@prefix ldes: <https://w3id.org/ldes#> .
@prefix tree: <https://w3id.org/tree#> .
@prefix ex: <http://example.org/> .

ex:eventstream a ldes:EventStream ;
    tree:view <> ;
    tree:member ex:member1, ex:member2 ;
    ldes:timestampPath ex:createdAt ;
    ldes:versionOfPath ex:versionOf .
```

The object of `tree:member` MUST be an IRI that identifies an immutable concept.

Note: To ensure immutability, the IRI should reference a resource that cannot change over time. A common approach is to include a timestamp, hash or version identifier in the IRI, so that each IRI corresponds to a specific, unalterable state or event.

If you add a member to multiple pages, this MUST be done atomically. This ensures that a client’s synchronization run is reliable: members emitted in the current run will not be newly encountered in future runs. This atomicity is a precondition for clients to safely forget parts of the log, as those members cannot be encountered again once the pages the members were encountered in become immutable.

If you reuse the member IRI as a named graph, clients MAY assume the payload of the upsert is in that named graph. Publish consistently so consumers can locate the triples for updates and deletions.

## Transactions ## {#transactions}

If you want to flag that certain members must be processed together (e.g., a large deletion operation), you can model transactions:
- Set `ldes:transactionPath` to identify the transaction (literal or IRI).
- Set `ldes:transactionFinalizedPath` whose object indicates the transaction is finalized.
- Optionally set `ldes:transactionFinalizedObject` to the value that denotes finalization (defaults to `"true"^^xsd:boolean`).

Producers SHOULD ensure the member that finalizes the transaction has an equal or later `ldes:timestampPath`/`ldes:sequencePath` than preceding transaction members so ordered clients can emit it last.

# Scaling # {#scaling}

Next to optimizations such as using a binary format such as [Jelly](https://jelly-rdf.github.io), or manually creating an aggregated summary LDES as a derived LDES, there are also two other tools one can use for scaling up.

## Retention policies: log compaction ## {#log-compaction}

Issue: section is still TODO

## Rebalancing the search tree ## {#rebalancing}

Rebalancing a search tree of an LDES is interesting for old immutable pages as most clients are going to be interested in the full history anyway. Compression becomes much more efficient on bigger pages, and thus less data will need to be transferred over the wire, saving bandwidth.

Rebalancing is tricky though, because a client might get stuck in edge cases when it is just replicating the datasets while the rebalancing is happening, and also a server cache might still have a copy of all or some of your immutable pages.

As a running example, imagine a client is synchronizing a day-page `2022-05-02` but then all pages under `2022` are getting merged into one.

A server MUST, in that case, provide redirects to a new IRI, such as `2022-rebalanced`, from all old pages, including the page `2022` to `2022-rebalanced`.

Note: the semantics of `ldes:immutable` are that the members on this page and the relations should not be processed again. The page MAY still be rebalanced later on, or the page can become unavailable on disk (`410 Gone`).

# Status log # {#status-log}

Issue: status log is still undefined

# Validating the pages # {#validating}

This section includes the rules to validate an implementation of a root node and any subsequent node.

Issue: we still need to build the SHACL shapes here.

Issue: we still need an UML image here.

## For the Root Node ## {#rootnode}

A root node MUST link the event stream to the view using the `tree:view` property.

A root node MUST contain context information about the LDES. All these properties in the domain of the event stream have a cardinality of 0 or 1:
- `ldes:timestampPath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:sequencePath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:versionOfPath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:versionTimestampPath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:versionSequencePath` : points to a SHACL property path (an rdf:List or an IRI)
- `tree:shape`: point to a `sh:NodeShape`.
- `ldes:versionCreatePath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:versionUpdatePath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:versionDeletePath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:versionCreateObject`
- `ldes:versionUpdateObject`
- `ldes:versionDeleteObject`
- `ldes:transactionPath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:transactionFinalizedPath`: points to a SHACL property path (an rdf:List or an IRI)
- `ldes:transactionFinalizedObject`

A root node MUST contain context information about this particular entry point:
- `ldes:retentionPolicy` 0 or 1. Although in older versions of the spec multiple were allowed.
- `tree:viewDescription` 0 or 1.

### For the Retention policies ### {#retention-policies}

A root node MUST contain at most one `ldes:retentionPolicy` property (cardinality: 0..1).  
The value of `ldes:retentionPolicy` MUST be an IRI referring to a retention policy description.

A retention policy description MAY contain the following properties, each with cardinality 0 or 1:

- `ldes:startingFrom` (0..1) If present, this property MUST be a `xsd:dateTime` literal indicating the earliest timestamp for retained members.

- `ldes:fullLogDuration` (0..1) If present, this property MUST be a duration literal specifying the time window for which all members are retained.

- `ldes:versionAmount` (0..1) If present, this property MUST be an integer literal specifying the number of versions to retain per entity.

- `ldes:versionDuration` (0..1) If present, this property MUST be a duration literal specifying the time window for which versions are retained.

- `ldes:versionDeleteDuration` (0..1) If present, this property MUST be a duration literal specifying the time window for which deletions are retained.

## Root Node and Subsequent Nodes ## {#nodes}

On the event stream, 0 or more `tree:member` triples are provided. The objects MUST be IRIs.

A `tree:view` triple MAY be present on the event stream to the current page `<>`.

A current page `<>` has 0 or more `tree:relation` properties to relations.

This page MAY also have `ldes:immutable true` attached to it.
The default value is false. If it is not immutable, this SHOULD NOT be made explicit using a `false` value.

### Immutability and Caching ### {#immutability}

- When a page becomes immutable, set `ldes:immutable true` in RDF and return `Cache-Control: immutable` at the HTTP level.
- Do not add or remove members from immutable pages. If a page needs correction, publish a new page and update relations.
- Return `ETag` for all pages; keep the `ETag` stable for identical content.

### HTTP Status Codes ### {#status-codes}

- `200 OK`: for successful node retrieval.
- `301/302`: MAY be used to redirect to a moved node.
- `304 Not Modified`: SHOULD be used with `If-None-Match` and `ETag`.
- `410 Gone`: use when a previously published node is permanently removed; respond with an empty set of relations and members.
- `429 Too Many Requests`: use for overload, optionally with `Retry-After`.
- `5xx`: use appropriately for server errors.

## Relations ## {#relations}

Relations in LDES are used to describe how pages or nodes are connected within the event stream. Each relation is represented using the `tree:relation` property and SHOULD specify its type and relevant properties.

On all relations, exactly one `tree:node` MUST be present. The object MUST be an IRI.

In case it is typed a `tree:GreaterThanRelation`, `tree:LessThanRelation`, `tree:EqualToRelation`, `tree:LessThanOrEqualToRelation`, or `tree:GreaterThanOrEqualToRelation`, each of these relations MUST specify exactly one `tree:path` (a [[!SHACL]] path) and `tree:value`.

For chronological views, you SHOULD use the same `tree:path` as the `ldes:timestampPath`. For time windows, publish both lower- and upper-bound relations to the same node; clients combine relations to the same node using logical AND. Avoid orphan relations and overlapping intervals that cause ambiguous traversal.

If a relation type isn’t understood by clients (e.g., a geospatial relation), provide an ordering-compatible path elsewhere so ordered clients can still discover early members.

### Versioning and Transactions (Producer Guidance) ### {#producer-versioning}

- If you publish versioned members, set `ldes:versionOfPath` and, when applicable, publish create/update/delete markers using `ldes:versionCreatePath`/`Object`, `ldes:versionUpdatePath`/`Object`, and `ldes:versionDeletePath`/`Object`.
- If versions are published out of chronological order, also set `ldes:versionTimestampPath` and optionally `ldes:versionSequencePath` to define the intended version order.
- If members participate in transactions, set `ldes:transactionPath` and indicate completion via `ldes:transactionFinalizedPath` and `ldes:transactionFinalizedObject`.
